In Linux systems it is possible to develop kernel routines and run them as if they were part of the kernel. This is accomplished through \gls{lkm} which are programs written specifically to the kernel that can be loaded at runtime. This feature brings a lot of advantages to developers enabling them to access low level resources from the kernel. Simple modules are easily written and installed. However, they are usually built to perform complex tasks at kernel level, leading to complex source code. When playing with kernel modules, developers must ensure that the code is not corrupted in any way, otherwise the system may stop abruptly leading to an unrecoverable state (usually designated as kernel panic).

\subsection{Building}

In order to get a \gls{lkm} to run on the kernel, the user must provide the \textit{entry} and \textit{exit} points. The former is called when the module is inserted into the kernel. The last is called when the module is removed from the kernel. 

The entry point is implemented as a function that is declared as \texttt{static} and should return the \texttt{int} value of 0. This \textit{init} function may have any name, and is defined as the entry point through the \texttt{module\_init()} primitive. For instance, if the init function is called \textit{"hello"}, the entry point is defined as follows:

\begin{lstlisting}[caption=Defining the Loadable Kernel Module's entry point]
module_init(hello);
\end{lstlisting}

The exit point is implemented as a function that is also declared as \texttt{static} but returns \texttt{void}. Similar to the entry point, the exit function may assume any name, but this should be passed as argument to the \texttt{module\_exit()} primitive. For instance, naming the exit function as \textit{"goodbye"}, the exit point is defined as follows:

\begin{lstlisting}[caption=Defining the Loadable Kernel Module's exit point]
module_exit(goodbye);
\end{lstlisting}

\subsection{Compiling}

The compilation process is accomplished using the \textit{make} utility. The developer should build a \textit{Makefile} providing the path to both the module's location and the kernel's libraries that will generate the \texttt{.ko} file. A simple example of such \textit{Makefile} is presented as follows:

\begin{lstlisting}[caption=Example of a Makefile to compile Loadable Kernel Modules]
obj-m := example_module.o

KDIR := /lib/modules/$(shell uname -r)/build
PWD := $(shell pwd)

all:
        $(MAKE) -C $(KDIR) M=$(PWD) modules

clean:
        $(MAKE) -C $(KDIR) M=$(PWD) clean
\end{lstlisting}

The source code file of the module above is called \texttt{example\_module.c} and the originated module file will be called \texttt{example\_module.ko}. Note the \texttt{uname -r} command that will give the kernel's version so that the compiled module is able to run in the same kernel. Developers must pay attention to kernel's versions in order to build compatible modules.

\subsection{Inserting and Removing}

Linux provides several commands to deal with kernel modules. To insert modules into the kernel, developers use the \texttt{insmod} command that takes a \texttt{.ko} file as argument. For instance, to insert the module presented above, the following command is executed:

\begin{lstlisting}[caption=Linux command to insert Loadable Kernel Modules]
# sudo insmod example_module
\end{lstlisting}

After executing this command, the module starts to run immediately by calling the entry point function. To remove the module, the following command must be executed:

\begin{lstlisting}[caption=Linux command to remove Loadable Kernel Modules]
# sudo rmmod example_module
\end{lstlisting}