Android provides a powerful toolset that has multiple purposes, called \gls{ndk}.  The Android \gls{ndk} was built to supply developers the capability to exploit the full power of mobile devices using native code. This is achieved through the \gls{jni}, which is a programming framework that provides connection between Java code that runs on the virtual machine and native code, as C/C++. Native code is accessed by the Java side as a static library, declared through the following statement:

\begin{lstlisting}[caption=Declare a JNI library in Java]
static { 
  System.loadLibrary("native");
}
\end{lstlisting}

This library called \texttt{native} implements a set of native methods called in Java. For instance, considering that the library implements two native methods named \texttt{nativeMethodA()} and \texttt{nativeMethodB()}. The following statements declare these methods:

\begin{lstlisting}[style=JavaInputStyle]
public native void nativeMethodA();
public native String nativeMethodB(String str);
\end{lstlisting}

At this point, Java knows that in order to execute the \texttt{nativeMethodA()} and the \texttt{nativeMethodB()} methods it has to inspect the \texttt{native} library stored as \texttt{libnative.so} and placed at \texttt{libs/armeabi/} in the Android project folder.

Developers are advise to create a new folder under the Android project directory, called \texttt{jni}. The native library consists of, at least, three files that should be placed at a this \texttt{jni} folder:

\begin{itemize}
\item the \texttt{Android.mk} configuration file;
\item the header file;
\item the C/C++ file.
\end{itemize}

The \texttt{Android.mk} file comprises several configurations required by the \textit{ndk-build} tool. This tool is brought by the Android \gls{ndk} and allows to compile native code generating library files as well as executable files. The minimum set of instructions in the \texttt{Android.mk} file is presented as follows:

\begin{lstlisting}[caption=The minimum set of instructions in the \texttt{Android.mk} file]
LOCAL_PATH := $(call my-dir)
 
include $(CLEAR_VARS)
       
LOCAL_MODULE    := native
LOCAL_SRC_FILES := native.c

include $(BUILD_SHARED_LIBRARY)
\end{lstlisting}

This file specifies:
\begin{itemize}
\item  the native source files location in \texttt{LOCAL\_PATH};
\item  the name of the library in \texttt{LOCAL\_MODULE};
\item  and the name of the native code file in \texttt{LOCAL\_SRC\_FILES}.
\end{itemize}

The statement \texttt{CLEAR\_VARS} indicates that no dependent configuration disrupts compilation \cite{AndroidNDK:Packt}. At last, the \texttt{include \$(BUILD\_SHARED\_LIBRARY)} statement instructs the \texttt{ndk-build} tool to build a shared library. As additional note, if the native code was intended to generate an executable file, the last instruction would be replaced by \texttt{include \$(BUILD\_EXECUTABLE)}.

The header file name follows the pattern: \texttt{<package\_name>\_<class>.h} . For instance, considering that the Java class responsible for loading the library is called \texttt{LoadLibrary} and the Java package that contains this class is called \texttt{com.android.droidguardian}. The name of the header file would be: \texttt{com\_android\_droidguardian\_LoadLibrary.h}. This file is automatically generated by a tool called \textit{javah} provided by the \gls{jdk}. It was designed to build header files to the \gls{jni} and may be used as follows:

\begin{lstlisting}[caption=Example of use of the javah tool]
# javah -jni -d <path_to_jni_folder> -classpath <path_to_class_files> \
com.android.droidguardian.LoadLibrary
\end{lstlisting}

This tool operates over \texttt{.class} files which means that the Java code must be previously compiled.

The native code goes on regular \texttt{.c/.cpp} files. The next section will introduce basic \gls{jni} concepts in order to get a native library running on Java.

\subsection{Java Native Interface concepts}

The \gls{jni} englobes a wide set of features to handle native code by means of a Java library. Starting with data types, the \gls{jni} maps primitive Java data types to native data types as shown in \autoref{tab:jni_data_types}.

\begin{table}[h]
\begin{center}
\begin{tabular}{| l | l | l | l |}
\hline
\textbf{Java Type} & \textbf{JNI Type} & \textbf{C/C++ Type} & \textbf{Size}\\
\hline
Boolean 1.5 & Jboolean & unsigned char & Unsigned 8 bits\\
\hline
Byte & Jbyte & char & Signed 8 bits\\
\hline
Char & Jchar & unsigned short & Unsigned 16 bits\\
\hline
Short & Jshort & short & Signed 16 bits\\
\hline
Int & Jint & Int & Signed 32 bits\\
\hline
Long & Jlong & long long & Signed 64 bits\\
\hline
Float & Jfloat & float & 32 bits\\
\hline
Double & Jdouble & double & 64 bits\\
\hline
\end{tabular}
\end{center}
\caption{JNI primitive data types mapping}
\label{tab:jni_data_types}
\end{table}

Regarding reference types, the \gls{jni} also maps Java and native types, as shown in \autoref{tab:jni_ref_data_types}.

\begin{table}[h]
\begin{center}
\begin{tabular}{| l | l |}
\hline
\textbf{Java Type} & \textbf{JNI Type}\\
\hline
java.lang.Class & jclass\\
\hline
java.lang.Throwable & jthrowable\\
\hline
java.lang.String & jstring\\
\hline
Other objects & jobjects\\
\hline
java.lang.Object[] & jobjectArray\\
\hline
\end{tabular}
\end{center}
\caption{JNI reference types mapping}
\label{tab:jni_ref_data_types}
\end{table}

\subsubsection{Strings}

Strings cannot be converted directly from Java into its native type. Therefore, there are specific methods to handle Strings, as well as other reference types. For instance, to convert a C string into a Java string the following instructions need to take place:

\begin{lstlisting}[caption=Creating a new Java string from a given C string]
jstring javaString;javaString = (*env)->NewStringUTF(env, "Hello World!");
\end{lstlisting}

Note that along with UTF strings, also Unicode strings are supported by the \gls{jni}. The \texttt{javaString} variable will be used by Java as a string that contains the value \textit{"Hello World!"}.

When the conversion needs to occur in the reverse order, the following steps need to be executed:

\begin{lstlisting}[caption=Creating a new C string from a given Java string]
char* str;str = (*env)->GetStringUTFChars(env, javaString, NULL);
(*env)->ReleaseStringUTFChars(env, javaString, str);
\end{lstlisting}

After converting the \texttt{javaString} into a new C string called \texttt{str}, the Java string needs to be released by calling the \texttt{ReleasingStringUTFChars()} function.

\subsubsection{Java fields}

The variables of Java classes, also called fields, may be accessed through the \gls{jni}. There are two types of fields: instance fields and static fields. When a class is instantiated, its instance variables are copied, but its static variables are not, which means that all instances of the class share the same static fields. As example, considering that a certain Java class presents the following fields:

\begin{lstlisting}[caption=Declaring Java fields]
private String instanceField = "Instance Field";
private static String staticField = "Static Field";
\end{lstlisting}

The first variable, \texttt{instanceField}, is accessed in the native code as follows:

\begin{lstlisting}[caption=Accessing a Java instance field]
jclass clazz;clazz = (*env)->GetObjectClass(env, instance);
jfieldID instanceFieldId;instanceFieldId = (*env)->GetFieldID(env, clazz, "instanceField", "Ljava/lang/String;");
\end{lstlisting}

At first, it was necessary to get the class object in order to inspect its fields. Then, the native type \texttt{jfieldID} assumes the native form of the Java field \texttt{instanceField}.  When using static fields, the function is very similar:

\begin{lstlisting}[caption=Acessing a Java static field]
jclass clazz;clazz = (*env)->GetObjectClass(env, instance);
jfieldID staticFieldId;staticFieldId = (*env)->GetStaticFieldID(env, clazz, "staticField", "Ljava/lang/String;");
\end{lstlisting}

Once Java fields are converted into native fields, it is possible to get or set its values:

\begin{lstlisting}[caption=Getting and setting a Java instance field value]
jstring jstr;
char *str;
jstr = (*env)->GetObjectField(env, clazz, instanceFieldId);
str = (*env)->GetStringUTFChars(env, jstr, 0);
(*env)->ReleaseStringUTFChars(env, jstr, str);

 jstr = (*env)->NewStringUTF(env, "Hello World!");
  (*env)->SetObjectField(env, clazz, fid, jstr);
\end{lstlisting}


\subsubsection{Java methods}

Like Java fields, Java methods can be handled by the \gls{jni}. Two types of methods are distinguished: instance methods and static methods. As example, considering that a certain Java class presents the following methods:

\begin{lstlisting}[caption=Declaring Java methods]
private String instanceMethod() {        return "Instance Method";
 }

 private static String staticMethod() {        return "Static Method";}
\end{lstlisting}

The related functions to access these methods are the following:

\begin{lstlisting}[caption=Acessing Java methods]
jmethodID instanceMethodId;instanceMethodId = (*env)->GetMethodID(env, clazz, "instanceMethod", "()Ljava/lang/String;");

jmethodID staticMethodId;staticMethodId = (*env)->GetStaticMethodID(env, clazz, "staticMethod", "()Ljava/lang/String;");
\end{lstlisting}

Note the last argument of both functions, that, in the example, took the value \texttt{"()Ljava/lang/String;"}. This defines the method descriptor which represents the method signature in Java. The \autoref{tab:java_sig} presents Java types and the corresponding signature.

\begin{table}[h]
\begin{center}
\begin{tabular}{| l | l |}
\hline
\textbf{Java Type} & \textbf{Signature}\\
\hline
Boolean & Z\\
\hline
Byte & B\\
\hline
Char & C\\
\hline
Short & S\\
\hline
Int & I\\
\hline
Long & J\\
\hline
Float & F\\
\hline
Double & D\\
\hline
type[] & [type\\
\hline
fully-qualified-class & Lfully-qualified-class;\\
\hline
method type & (arg-type)ret-type\\
\hline
\end{tabular}
\end{center}
\caption{Java types and signatures}
\label{tab:java_sig}
\end{table}

The \gls{jdk} provides an useful tool named Java Class File Disassembler, available as a command line called \textit{javap}. This tool can be used to extract the method signature from the compiled class files:

\begin{lstlisting}[caption=Example of use of the javap tool]
# javap –classpath bin/classes –p –s com.android.droidguardian
\end{lstlisting}

The source code and tables present in this section was inspired by \cite{AndroidNDK:Apress}.