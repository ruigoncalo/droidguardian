Typically, developers find every resources they need in the Android \gls{sdk}. When some resources are missing, Android provides the \gls{ndk} so that they can bring the potential of native code to their applications. But, sometimes there are situations where it is necessary to go deeper into the Android software stack. This is one of those situations. In order to be able to reject an internet connection in real time, the operation must be executed at kernel level. The \gls{lsm} framework is the basis of DroidGuardian, providing the ability to deny an internet connection. This section explains in detail the \gls{lsm} framework and how it allows to operate with internet connections requests.

\subsection{Introduction}

In 2001, Peter Loscocco and Stephen Smalley wrote an article introducing the \gls{sel} \cite{LS01}. The main reason that led to the development of such mechanism was the flawed assumption that adequate security should reside in applications, leaving the role of the operating system behind \cite{LSMTTF98}. They supported the idea that secure applications require secure operating systems. A strong concept related to operating systems security is \textit{access control policy}. In a simple manner, this term specifies what operations associated with an object are authorized to perform. Linux kernel inherited from the UNIX security model the \gls{dac} that allows the owner of an object to set the security policy for that object (the control of access is based on the discretion of the owner). However, this model of access control brings some advantages. For instance, every program executed by a certain user receives all of the privileges associated with that user. Therefore it is able to change the permissions of all user's objects, creating potential security threats. In this sense, a \gls{mac} was purposed to protect the system against vulnerabilities left by other access control models. In \gls{mac} the operating system constrains the ability of a subject to perform an operation on an object, depending on the security attributes. Whenever a subject attempts to access an object, an authorization rule enforced by the operating system kernel checks these security attributes in order to allow or deny the access.

At the Linux Kernel 2.5 Summit, the \gls{nsa}, based on the security issues previously mentioned, presented their work on \gls{sel}, a security mechanism of a flexible access control architecture in the Linux kernel. \gls{nsa} reiterated the need for such support in the mainstream Linux kernel. Other projects were presented to enforce access policies, namely \gls{dte}, \gls{lids} and POSIX.1e capabilities. Given these projects, Linus Torvalds decided to provide a general framework for security policy, called \gls{lsm}. This framework allow many different access control models to be implemented as loadable kernel modules. Linus enforced that \gls{lsm} should be truly generic, where using a different security model was a question of loading a different kernel module. The framework should also be conceptually simple, minimally invasive and efficient. At last, the mechanism should be able to support the POSIX.1e capabilities logic as an optional security module \cite{WCSMK02}.

This security framework has motivated developers and gave them freedom to build their own \gls{lsm} according to how they consider that kernel objects should be accessed. \gls{sel}\footnote{http://selinuxproject.org} was originally developed by the \gls{nsa} and has been in the mainstream kernel since version 2.6 (December 2003). \gls{sel} presents three forms of access control, \gls{dte}, \gls{rbac} and \gls{mls}. It uses the filesystem to mark executables when keeping track of permissions.

Smack (Simple Mandatory Access Control Kernel)\footnote{http://schaufler-ca.com} has been in the mainstream kernel since version 2.6.26 (July 2008). This module was implemented to provide simplicity to users. The complexity of \gls{dte} is avoided by defining access controls in terms of the access modes already in use.

AppArmor (Application Armor)\footnote{http://wiki.apparmor.net} was originally developed by Immunix, which was a commercial operating system acquired by Novell in 2005. Novell laid off AppArmor programmers in 2007, but they continued the work. Since 2009, Canonical contributes to the project. This module has been in the mainstream Linux kernel since version 2.6.36 (October 2010). While \gls{sel} is based on applying labels to files, AppArmor uses pathnames to make security decisions. For instance, two different security policies may be applied  to the same file if that file is accessed by way of two different names. Many Linux administrators claim that AppArmor is the easiest security module to configure. Yet, others state that a pathname-based mechanism is insecure and that security policies should apply directly to objects (or to labels attached directly to objects) rather than to names given to objects.

TOMOYO Linux\footnote{http://tomoyo.sourceforge.jp} is another \gls{mac} implementation for Linux. It has been in the mainstream kernel since version 2.6.30 (June 2009). This security mechanism follows the pathname-based philosophy, like AppArmor. TOMOYO Linux focuses on the behavior of a system, allowing each process to declare behaviors and resources needed to achieve its purpose. A precise comparison chart is available at \url{http://tomoyo.sourceforge.jp/wiki-e/?WhatIs#comparison}.

Recently, Yama has been added to the mainstream kernel since version 3.4 (May 2012). Yama is a \gls{lsm} that collects a number of system wide \gls{dac} security protections that are not handled by the core kernel itself.

Since the first release of the \gls{lsm} framework that new updates are committed in almost every new version of the Linux kernel. It is important to refer that between version 2.6.25 and 2.6.27, the \gls{lsm} boot engine changed and became no longer a removable module. Since then, the \gls{lsm} is loaded at compile time.

\subsection{Design}

The basic abstraction of the \gls{lsm} interface is to intercede in the access to internal kernel objects. Security modules should answer a simple question "May a subject \texttt{S} perform a kernel operation \texttt{OP} on an internal kernel object \texttt{OBJ}?". The mechanism that allow modules to execute this task lies in \textit{hook} functions that are placed in the kernel code, as shown in \autoref{fig:lsm_arch}.

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.5]{figures/LSM_architecture.png}
 \caption{LSM hook functions architecture}
 \label{fig:lsm_arch}
\end{figure}

Immediately before the kernel access the object, represented as \textit{inode} in \autoref{fig:lsm_arch}, the hook makes a call to a function that the \gls{lsm} must provide. The module, based on policy rules, either allow or deny the access, forcing an error code return in the last case.

\subsection{Implementation}

The \gls{lsm} framework comprises a few files in the kernel. \autoref{fig:kernel_files} highlights the relevant files that implement the security mechanism.

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.5]{figures/kernel_files.jpg}
 \caption{\gls{lsm} framework files in the Linux kernel}
 \label{fig:kernel_files}
\end{figure}

\subsubsection{Header file}
\label{sec:header_file}

The \texttt{include/linux/security.h} file contains the hook functions declarations. The source code may be divided into two parts, depending on the value of the conditional group \texttt{CONFIG\_SECURITY} being true or false. In the first case, an extensive structure with pointers to all hook functions is declared. If false, only default functions are declared and the kernel loads the default security module. The code snippet in \autoref{lst:struct_ops}, extracted from the Linux kernel v3.11, presents the initial function pointers in the structure \texttt{security\_operations}.

\begin{lstlisting}[style=CInputStyle, caption=Security structure declaration (Linux kernel v3.11), label=lst:struct_ops]
struct security_operations {
	char name[SECURITY_NAME_MAX + 1];

	int (*ptrace_access_check) (struct task_struct *child, unsigned int mode);
	int (*ptrace_traceme) (struct task_struct *parent);
	int (*capget) (struct task_struct *target,
		       kernel_cap_t *effective,
		       kernel_cap_t *inheritable, kernel_cap_t *permitted);
	int (*capset) (struct cred *new,
		       const struct cred *old,
		       const kernel_cap_t *effective,
		       const kernel_cap_t *inheritable,
		       const kernel_cap_t *permitted);
	int (*capable) (const struct cred *cred, struct user_namespace *ns,
			int cap, int audit);
	int (*quotactl) (int cmds, int type, int id, struct super_block *sb);
	int (*quota_on) (struct dentry *dentry);
	int (*syslog) (int type);
	int (*settime) (const struct timespec *ts, const struct timezone *tz);
	int (*vm_enough_memory) (struct mm_struct *mm, long pages);
\end{lstlisting}

Along with the structure, the functions prototypes are declared, as shown in \autoref{lst:hooks}. Some security hooks are declared depending on conditional groups:

\begin{itemize}
 \item \texttt{CONFIG\_SECURITY\_PATH}, includes security hooks for pathname based access control;
 \item \texttt{CONFIG\_SECURITY\_NETWORK}, enables socket and network security hooks;
 \item \texttt{CONFIG\_SECURITY\_NETWORK\_XFRM}, security hooks for XFRM framework, that implement per-packet access controls based on labels derived from IPSec policy;
\item \texttt{CONFIG\_KEYS}, provides support for retaining authentication tokens and access keys in the kernel;
\item \texttt{CONFIG\_AUDIT}, enables auditing infrastructure that can be used with another kernel subsystem.
\end{itemize}

\begin{lstlisting}[style=CInputStyle, caption=Security functions declaration (Linux kernel v3.11), label=lst:hooks]
int security_ptrace_access_check(struct task_struct *child, unsigned int mode);
int security_ptrace_traceme(struct task_struct *parent);
int security_capget(struct task_struct *target,
		    kernel_cap_t *effective,
		    kernel_cap_t *inheritable,
		    kernel_cap_t *permitted);
int security_capset(struct cred *new, const struct cred *old,
		    const kernel_cap_t *effective,
		    const kernel_cap_t *inheritable,
		    const kernel_cap_t *permitted);
int security_capable(const struct cred *cred, struct user_namespace *ns,
			int cap);
int security_capable_noaudit(const struct cred *cred, struct user_namespace *ns,
			     int cap);
int security_quotactl(int cmds, int type, int id, struct super_block *sb);
int security_quota_on(struct dentry *dentry);
int security_syslog(int type);
int security_settime(const struct timespec *ts, const struct timezone *tz);
int security_vm_enough_memory_mm(struct mm_struct *mm, long pages);
\end{lstlisting}


If the configurable option \texttt{CONFIG\_SECURITY} is not selected, the default security module is loaded. This module only executes a few capabilities, being permissive in all other hooks, which means that allow access to all kernel internal objects. \autoref{lst:default_hooks} exhibits some of these hooks' source code.

\begin{lstlisting}[style=CInputStyle, caption=Default security functions (Linux kernel v3.11), label=lst:default_hooks]
static inline int security_capable(const struct cred *cred,
				   struct user_namespace *ns, int cap)
{
	return cap_capable(cred, ns, cap, SECURITY_CAP_AUDIT);
}

static inline int security_capable_noaudit(const struct cred *cred,
					   struct user_namespace *ns, int cap) {
	return cap_capable(cred, ns, cap, SECURITY_CAP_NOAUDIT);
}

static inline int security_quotactl(int cmds, int type, int id,
				     struct super_block *sb)
{
	return 0;
}

static inline int security_quota_on(struct dentry *dentry)
{
	return 0;
}

static inline int security_syslog(int type)
{
	return 0;
}
\end{lstlisting}


The same process is kept to the other configurable options. Depending on their values, security hooks are either declared or coded with default instructions.

\subsubsection{Linux capabilities}
\label{sec:linux_capabilities}

Linux capabilities were designed to provide a solution to the UNIX-style user privilege set composed by privilege users (root) and non-privilege users (regular user). The first type has permission to execute every operation and the former can only execute a few set of operations. Therefore, processes run either with all permissions or with very restrictive permissions. Unfortunately, most of the time processes do not need all privileges to execute a task and this exposure raises serious risks when a process gets compromised \cite{Wiki:Capabilities}.

In the scope of \gls{lsm}, a set of functions, called \textit{common capabilities}, were developed to give the security framework a default behavior in the case no other \gls{lsm} is loaded. These functions are plugged in the kernel to overcome the problem mentioned above. In \texttt{security/commoncap.c} we can see the source code of these functions.

If no \gls{lsm} is loaded, there must be a default function hook that does not execute any operation and let the process access kernel internal objects. The file \texttt{security/capability.c} have all hook functions with the default code. If the return type is \texttt{void}, functions have no operations, otherwise is \texttt{int} and functions just \texttt{return 0}, which is the value to turn the hook permissive. \autoref{lst:cap_hooks} shows some of these hook functions.

\begin{lstlisting}[style=CInputStyle, caption=Capability functions (Linux kernel v3.11), label=lst:cap_hooks]
static int cap_syslog(int type)
{
	return 0;
}

static int cap_quotactl(int cmds, int type, int id, struct super_block *sb)
{
	return 0;
}

static int cap_quota_on(struct dentry *dentry)
{
	return 0;
}

static int cap_bprm_check_security(struct linux_binprm *bprm)
{
	return 0;
}

static void cap_bprm_committing_creds(struct linux_binprm *bprm)
{
}
\end{lstlisting}

These functions are called in the structure \texttt{security\_operations} if the respective hook functions are not declared. \autoref{lst:fixup_ops} presents the code snippet of the function \texttt{security\_fixup\_ops}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{security\_fixup\_ops} function (Linux kernel v3.11), label=lst:fixup_ops]
#define set_to_cap_if_null(ops, function)				\
	do {								\
		if (!ops->function) {					\
			ops->function = cap_##function;			\
			pr_debug("Had to override the " #function	\
				 " security operation with the default.\n");\
			}						\
	} while (0)

void __init security_fixup_ops(struct security_operations *ops)
{
	set_to_cap_if_null(ops, ptrace_access_check);
	set_to_cap_if_null(ops, ptrace_traceme);
	set_to_cap_if_null(ops, capget);
	set_to_cap_if_null(ops, capset);
	set_to_cap_if_null(ops, capable);
	set_to_cap_if_null(ops, quotactl);
	set_to_cap_if_null(ops, quota_on);
	set_to_cap_if_null(ops, syslog);
	set_to_cap_if_null(ops, settime);
	set_to_cap_if_null(ops, vm_enough_memory);
(...)
}
\end{lstlisting}

\subsubsection{Framework initialization}
\label{sec:framework_initialization}

The header file mentioned in \autoref{sec:header_file} declares some functions in charge of getting the \gls{lsm} loaded, as shown in \autoref{lst:init_functions}.

\begin{lstlisting}[style=CInputStyle, caption=Framework initialization functions (Linux kernel v3.11), label=lst:init_functions]
/* prototypes */
extern int security_init(void);
extern int security_module_enable(struct security_operations *ops);
extern int register_security(struct security_operations *ops);
extern void __init security_fixup_ops(struct security_operations *ops);
\end{lstlisting}

These functions are implemented in \texttt{security/security.c}. The first function being executed is \texttt{security\_init}. The source code is present in \autoref{lst:security_init_func}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{security\_init} function (Linux kernel v3.11), label=lst:security_init_func]
/* Boot-time LSM user choice */
static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =
	CONFIG_DEFAULT_SECURITY;

static struct security_operations *security_ops;
static struct security_operations default_security_ops = {
	.name	= "default",
};

(...)

int __init security_init(void)
{
	printk(KERN_INFO "Security Framework initialized\n");

	security_fixup_ops(&default_security_ops);
	security_ops = &default_security_ops;
	do_security_initcalls();

	return 0;
}
\end{lstlisting}

At first, the default module is loaded with the available routines cited in \autoref{sec:linux_capabilities}, by \texttt{security\_fixup\_ops(\&default\_security\_ops)}. Then \texttt{security\_init()} updates the kernel's security structure \texttt{security\_ops} with the data earlier initialized and makes a call to \texttt{do\_security\_initcalls()} that implements a loop presented in \autoref{lst:sec_initcalls}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{do\_security\_initcalls} function (Linux kernel v3.11), label=lst:sec_initcalls]
static void __init do_security_initcalls(void)
{
	initcall_t *call;
	call = __security_initcall_start;
	while (call < __security_initcall_end) {
		(*call) ();
		call++;
	}
}
\end{lstlisting}

The callbacks \texttt{\_\_security\_initcall\_start} and \texttt{\_\_security\_initcall\_end} are declared in \texttt{include/linux/init.h} and the code snippet is shown in \autoref{lst:initcalls}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{init} callbacks (Linux kernel v3.11), label=lst:initcalls]
/*
 * Used for initialization calls..
 */
typedef int (*initcall_t)(void);
typedef void (*exitcall_t)(void);

extern initcall_t __con_initcall_start[], __con_initcall_end[];
extern initcall_t __security_initcall_start[], __security_initcall_end[];
\end{lstlisting}

\subsubsection{LSM registration}
There are several \gls{lsm} implementations adopted in the kernel, but this only runs one at a time. Therefore, there must be a way to register the desired \gls{lsm}. This is achieved through the execution of \texttt{register\_security(struct security\_operations *ops)}, exhibited in \autoref{lst:register_sec}

\begin{lstlisting}[style=CInputStyle, caption=\texttt{register\_security} function (Linux kernel v3.11), label=lst:register_sec]
int __init register_security(struct security_operations *ops)
{
	if (verify(ops)) {
		printk(KERN_DEBUG "%s could not verify "
		       "security_operations structure.\n", __func__);
		return -EINVAL;
	}

	if (security_ops != &default_security_ops)
		return -EAGAIN;

	security_ops = ops;

	return 0;
}
\end{lstlisting}

Some rudimentary check is done on the structure \texttt{ops} by \texttt{verify(struct security\_operations *ops)}. If there is already a security module registered with the kernel, an error will be returned. Otherwise, the structure \texttt{security\_ops} gets the hook functions in the structure \texttt{ops} and return success.\\

There is other important function related to the \gls{lsm} registration, that is \texttt{security\_module\_enable}. Each \gls{lsm} must pass this method before registering its own operations to avoid security registration races. This method may also be used to check if the \gls{lsm} is currently loaded during kernel initialization. \autoref{lst:sec_mod_enable} presents this function.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{register\_security} function (Linux kernel v3.11), label=lst:sec_mod_enable]
int __init security_module_enable(struct security_operations *ops)
{
	return !strcmp(ops->name, chosen_lsm);
}
\end{lstlisting}

At last, the security functions declarations previously mentioned in \autoref{sec:header_file}, are implemented by returning the function callback present in the structure \texttt{security\_operations}. A code snippet is available at \autoref{lst:security_func_code}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{register\_security} function (Linux kernel v3.11), label=lst:security_func_code]
int security_socket_create(int family, int type, int protocol, int kern)
{
	return security_ops->socket_create(family, type, protocol, kern);
}

int security_socket_post_create(struct socket *sock, int family,
				int type, int protocol, int kern)
{
	return security_ops->socket_post_create(sock, family, type,
						protocol, kern);
}

int security_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
{
	return security_ops->socket_bind(sock, address, addrlen);
}

int security_socket_connect(struct socket *sock, struct sockaddr *address, int addrlen)
{
	return security_ops->socket_connect(sock, address, addrlen);
}
\end{lstlisting}

\subsubsection{Security functions in the kernel}
\label{sec:security_func}

Security functions presented in the previous subsection are called depending on each objective. For instance, the \texttt{socket\_create} hook is part of the socket implementation, in \texttt{net/socket.c}. Note the code snippet in \autoref{lst:socket_create}.

\begin{lstlisting}[style=CInputStyle, caption=\texttt{socket\_create} hook in socket implementation (Linux kernel v3.11), label=lst:socket_create]
int sock_create_lite(int family, int type, int protocol, struct socket **res)
{
	int err;
	struct socket *sock = NULL;

	err = security_socket_create(family, type, protocol, 1);
	if (err)
		goto out;
(...)
}

int __sock_create(struct net *net, int family, int type, int protocol,
			 struct socket **res, int kern)
{
	int err;
	struct socket *sock;
	const struct net_proto_family *pf;
(...)
	err = security_socket_create(family, type, protocol, kern);
	if (err)
		return err;
(...)
}
\end{lstlisting}

This hook is simply a flag in which the returned value is checked and if it is different from \texttt{0}, the kernel blocks the socket creation. That is the reason why the default capability functions always return \texttt{0}.


