Android provides a powerful toolset that has multiple purposes, available at \url{http://developer.android.com/tools/sdk/ndk/index.html}.  The Android \gls{ndk} was built to supply developers the capability to exploit the full power of mobile devices using native code. This is achieved through the \gls{jni}, which is a programming framework that provides connection between Java code that runs on the virtual machine and native code, as C/C++. Native code is accessed by the Java side as a static library, declared through the following statement:

\begin{lstlisting}[style=JavaInputStyle]
static { 
  System.loadLibrary("native");
}
\end{lstlisting}

This \texttt{native} library implements a set of native methods called in Java. For instance:

\begin{lstlisting}[style=JavaInputStyle]
public native void nativeMethodA();
public native String nativeMethodB(String str);
\end{lstlisting}

At this point, Java knows that in order to execute the \texttt{nativeMethodA()} and the \texttt{nativeMethodB()}  it has to inspect the \texttt{native} library stored as \texttt{libnative.so} placed at \texttt{libs/armeabi/} in the Android project folder.

This library consists of, at least, three files that should be placed at a folder called \texttt{jni}:

\begin{itemize}
\item the \texttt{Android.mk} configuration file;
\item the header file;
\item the C/C++ file.
\end{itemize}

The \texttt{Android.mk} file comprises several configurations required by the \textit{ndk-build} tool. This tool is brought by the Android \gls{ndk} and allows to compile native code generating library files as well as executable files. The minimum intructions of an \texttt{Android.mk} file are presented as follows:

\begin{lstlisting}[style=CInputStyle]
LOCAL_PATH := $(call my-dir)
 
include $(CLEAR_VARS)
       
LOCAL_MODULE    := native
LOCAL_SRC_FILES := native.c

include $(BUILD_SHARED_LIBRARY)
\end{lstlisting}

This file specifies the native source files location, in \texttt{LOCAL\_PATH}, the name of both the library and the native code file, in \texttt{LOCAL\_MODULE} and \texttt{LOCAL\_SRC\_FILES}. The statement \texttt{CLEAR\_VARS} indicates no dependent configuration disrupts compilation \cite{AndroidNDK:Packt}. At last \texttt{BUILD\_SHARED\_LIBRARY} instructs to build a shared library.

The header file name follows a pattern: \texttt{<package\_name>\_<class>.h} . Imagine that the Java class that loaded the library is called \texttt{LoadLibrary} and the Java package that contains this class is called \texttt{com.android.droidguardian}. The name of the header file will be: \\
\texttt{com\_android\_droidguardian\_LoadLibrary.h}\\
\noindent This file is automatically generated by a tool called \textit{javah} provided by the \gls{jdk}. It was designed to build header files to the \gls{jni} and may be called as follows:

\begin{lstlisting}[style=BashInputStyle]
# javah -jni -d <path_to_jni_folder> -classpath <path_to_class_files> com.android.droidguardian.LoadLibrary
\end{lstlisting}

This tool operates over \texttt{.class} files which means that the Java code must be compiled before.

The native code goes on regular \texttt{.c/.cpp} files. The next section will introduce basic \gls{jni} concepts in order to get a native library running on Java.

\subsection{JNI concepts}


